import { momentClient, Feed, Comment } from '@wfc/moment_client';
import { FeedViewModel, FeedListState, FeedInteractionEvents, CommentInputState } from '../model/FeedViewModel';
import { MomentConstants, TimeFormatter } from '../utils/MomentConstants';
import { FeedItemComponent } from '../components/FeedItemComponent';
import wfc from '@wfc/client';
import { momentNavigationDestinations } from '../../../../Index';

@Component
export struct FeedListPage {
    // çŠ¶æ€ç®¡ç†
    @State feedListState: FeedListState = {
        feeds: [],
        isLoading: false,
        isRefreshing: false,
        isLoadingMore: false,
        hasMore: true,
        error: undefined
    };
    @State commentInputState: CommentInputState = {
        isVisible: false,
        feedId: undefined,
        replyTo: undefined,
        replyToName: undefined,
        placeholder: 'å†™è¯„è®º...'
    };
    @State commentText: string = '';
    // å½“å‰ç”¨æˆ·ID
    private currentUserId: string = '';

    @Consume('mainNavPathStack') mainNavPathStack: NavPathStack;

    aboutToAppear() {
        // èŽ·å–å½“å‰ç”¨æˆ·ID
        this.currentUserId = wfc.getUserId()
        this.loadInitialFeeds();
    }

    /**
     * åŠ è½½åˆå§‹æœ‹å‹åœˆæ•°æ®
     */
    private loadInitialFeeds() {
        this.feedListState.isLoading = true;

        momentClient.getFeeds(
            BigInt(0), // ä»Žæœ€æ–°å¼€å§‹
            20, // èŽ·å–20æ¡
            null, // èŽ·å–æ‰€æœ‰ç”¨æˆ·çš„æœ‹å‹åœˆ
            (feeds: Feed[]) => {
                this.feedListState.feeds = feeds.map(feed => new FeedViewModel(feed));
                this.feedListState.isLoading = false;
                this.feedListState.error = undefined;
            },
            (errorCode: number) => {
                this.feedListState.isLoading = false;
                this.feedListState.error = `åŠ è½½å¤±è´¥: ${errorCode}`;
                console.error('Load feeds failed:', errorCode);
            }
        );
    }

    /**
     * ä¸‹æ‹‰åˆ·æ–°
     */
    private onRefresh() {
        this.feedListState.isRefreshing = true;

        momentClient.getFeeds(
            BigInt(0),
            20,
            null,
            (feeds: Feed[]) => {
                this.feedListState.feeds = feeds.map(feed => new FeedViewModel(feed));
                this.feedListState.isRefreshing = false;
                this.feedListState.error = undefined;
            },
            (errorCode: number) => {
                this.feedListState.isRefreshing = false;
                this.feedListState.error = `åˆ·æ–°å¤±è´¥: ${errorCode}`;
            }
        );
    }

    /**
     * åŠ è½½æ›´å¤š
     */
    private onLoadMore() {
        if (this.feedListState.isLoadingMore || !this.feedListState.hasMore) {
            return;
        }

        this.feedListState.isLoadingMore = true;

        const lastFeed = this.feedListState.feeds[this.feedListState.feeds.length - 1];
        const fromIndex = lastFeed?.feed.feedId || BigInt(0);

        momentClient.getFeeds(
            fromIndex,
            20,
            null,
            (feeds: Feed[]) => {
                if (feeds.length === 0) {
                    this.feedListState.hasMore = false;
                } else {
                    this.feedListState.feeds.push(...feeds.map(feed => new FeedViewModel(feed)));
                }
                this.feedListState.isLoadingMore = false;
            },
            (errorCode: number) => {
                this.feedListState.isLoadingMore = false;
                console.error('Load more feeds failed:', errorCode);
            }
        );
    }

    /**
     * äº¤äº’äº‹ä»¶å¤„ç†
     */
    private interactionEvents: FeedInteractionEvents = {
        onLike: (feed: FeedViewModel) => {
            if (feed.isLiking) {
                return;
            }

            feed.isLiking = true;
            const isLiked = feed.isLiked(this.currentUserId);

            if (isLiked) {
                // å–æ¶ˆç‚¹èµž - éœ€è¦æ‰¾åˆ°å¯¹åº”çš„ç‚¹èµžè¯„è®ºå¹¶åˆ é™¤
                const likeComment = feed.getLikesList().find(like => like.sender === this.currentUserId);
                if (likeComment && likeComment.commentId && feed.feed.feedId) {
                    momentClient.deleteComment(
                        likeComment.commentId,
                        feed.feed.feedId,
                        () => {
                            // ä»Žæœ¬åœ°ç§»é™¤ç‚¹èµž
                            if (feed.feed.comments) {
                                const index = feed.feed.comments.findIndex(c => c.commentId === likeComment.commentId);
                                if (index !== -1) {
                                    feed.feed.comments.splice(index, 1);
                                }
                            }
                            feed.isLiking = false;
                        },
                        (errorCode: number) => {
                            feed.isLiking = false;
                            console.error('Unlike failed:', errorCode);
                        }
                    );
                }
            } else {
                // ç‚¹èµž
                if (feed.feed.feedId) {
                    momentClient.postComment(
                        1, // FeedCommentType.Comment_Thumbup_Type
                        feed.feed.feedId,
                        '',
                        '',
                        '',
                        (commentId: bigint, timestamp: number) => {
                            // æ·»åŠ åˆ°æœ¬åœ°ç‚¹èµžåˆ—è¡¨
                            const newLike = {
                                'commendId': commentId,
                                'feedId': feed.feed.feedId,
                                'sender': this.currentUserId,
                                'type': 1,
                                'text': '',
                                'replyTo': '',
                                'serverTime': timestamp,
                                'extra': ''
                            } as Record<string, Object>;

                            if (!feed.feed.comments) {
                                feed.feed.comments = [];
                            }
                            let comment = new Comment()
                            comment.fromJsonObject(newLike);
                            feed.feed.comments.push(comment);
                            feed.isLiking = false;
                        },
                        (errorCode: number) => {
                            feed.isLiking = false;
                            console.error('Like failed:', errorCode);
                        }
                    );
                }
            }
        },

        onComment: (feed: FeedViewModel, commentText: string, replyTo?: string) => {
            if (feed.isCommenting || !commentText.trim()) {
                return;
            }

            feed.isCommenting = true;

            if (feed.feed.feedId) {
                momentClient.postComment(
                    0, // FeedCommentType.Comment_Comment_Type
                    feed.feed.feedId,
                    commentText.trim(),
                    replyTo || '',
                    '',
                    (commentId: bigint, timestamp: number) => {
                        // æ·»åŠ åˆ°æœ¬åœ°è¯„è®ºåˆ—è¡¨
                        const newComment = {
                            'commentId': commentId,
                            'feedId': feed.feed.feedId,
                            'sender': this.currentUserId,
                            'type': 0,
                            'text': commentText.trim(),
                            'replyTo': replyTo || '',
                            'serverTime': timestamp,
                            'extra': ''
                        } as Record<string, Object>;

                        if (!feed.feed.comments) {
                            feed.feed.comments = [];
                        }
                        let comment = new Comment()
                        comment.fromJsonObject(newComment)
                        feed.feed.comments.push(comment);
                        feed.isCommenting = false;

                        // éšè—è¯„è®ºè¾“å…¥æ¡†
                        this.commentInputState.isVisible = false;
                        this.commentText = '';
                    },
                    (errorCode: number) => {
                        feed.isCommenting = false;
                        console.error('Comment failed:', errorCode);
                    }
                );
            }
        },

        onDelete: (feed: FeedViewModel) => {
            // TODO: æ˜¾ç¤ºç¡®è®¤åˆ é™¤å¯¹è¯æ¡†
            if (feed.feed.feedId) {
                momentClient.deleteFeed(
                    feed.feed.feedId,
                    () => {
                        // ä»Žåˆ—è¡¨ä¸­ç§»é™¤
                        const index = this.feedListState.feeds.findIndex(f => f.feed.feedId === feed.feed.feedId);
                        if (index !== -1) {
                            this.feedListState.feeds.splice(index, 1);
                        }
                    },
                    (errorCode: number) => {
                        console.error('Delete feed failed:', errorCode);
                    }
                );
            }
        },

        onUserClick: (userId: string) => {
            // TODO: è·³è½¬åˆ°ç”¨æˆ·è¯¦æƒ…é¡µ
            console.log('User clicked:', userId);
        },

        onImageClick: (images, index: number) => {
            // TODO: æ‰“å¼€å›¾ç‰‡é¢„è§ˆ
            console.log('Image clicked:', index);
        },

        onMoreComments: (feed: FeedViewModel) => {
            feed.showAllComments = true;
        }
    };

    /**
     * æ˜¾ç¤ºè¯„è®ºè¾“å…¥æ¡†
     */
    private showCommentInput(feed: FeedViewModel, replyTo?: string, replyToName?: string) {
        this.commentInputState = {
            isVisible: true,
            feedId: feed.feed.feedId,
            replyTo,
            replyToName,
            placeholder: replyTo ? `å›žå¤ ${replyToName || replyTo}:` : 'å†™è¯„è®º...'
        };
    }

    build() {
        NavDestination() {
            Column() {
                // ä¸»å†…å®¹åŒºåŸŸ
                if (this.feedListState.isLoading && this.feedListState.feeds.length === 0) {
                    // åˆå§‹åŠ è½½çŠ¶æ€
                    this.buildLoadingView()
                } else if (this.feedListState.error && this.feedListState.feeds.length === 0) {
                    // é”™è¯¯çŠ¶æ€
                    this.buildErrorView()
                } else {
                    // æœ‹å‹åœˆåˆ—è¡¨
                    this.buildFeedList()
                }

                // è¯„è®ºè¾“å…¥æ¡†
                if (this.commentInputState.isVisible) {
                    this.buildCommentInput()
                }

                // å‘å¸ƒæŒ‰é’®
                this.buildFloatingActionButton()
            }
            .width('100%')
            .height('100%')
            .backgroundColor(MomentConstants.BACKGROUND_COLOR)
        }
        .title('æœ‹å‹åœˆ')
        .backgroundColor(MomentConstants.BACKGROUND_COLOR)
    }

    @Builder
    private buildLoadingView() {
        Column() {
            LoadingProgress()
                .width(40)
                .height(40)
                .color(MomentConstants.PRIMARY_COLOR)

            Text('åŠ è½½ä¸­...')
                .fontSize(MomentConstants.FONT_SIZE_MEDIUM)
                .fontColor(MomentConstants.TEXT_SECONDARY_COLOR)
                .margin({ top: 8 })
        }
        .width('100%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
    }

    @Builder
    private buildErrorView() {
        Column() {
            Text('ðŸ˜ž')
                .fontSize(48)
                .margin({ bottom: 16 })

            Text(this.feedListState.error || 'åŠ è½½å¤±è´¥')
                .fontSize(MomentConstants.FONT_SIZE_MEDIUM)
                .fontColor(MomentConstants.TEXT_SECONDARY_COLOR)
                .margin({ bottom: 16 })

            Button('é‡è¯•')
                .backgroundColor(MomentConstants.PRIMARY_COLOR)
                .borderRadius(MomentConstants.BORDER_RADIUS)
                .onClick(() => {
                    this.loadInitialFeeds();
                })
        }
        .width('100%')
        .height('100%')
        .justifyContent(FlexAlign.Center)
        .alignItems(HorizontalAlign.Center)
    }

    @Builder
    private buildFeedList() {
        Refresh({ refreshing: $$this.feedListState.isRefreshing, offset: 64, friction: 100 }) {
            List({ space: 0 }) {
                ForEach(this.feedListState.feeds, (feedItem: FeedViewModel, index: number) => {
                    ListItem() {
                        FeedItemComponent({
                            feedViewModel: feedItem,
                            currentUserId: this.currentUserId,
                            events: this.interactionEvents,
                            onCommentClick: (replyTo?: string, replyToName?: string) => {
                                this.showCommentInput(feedItem, replyTo, replyToName);
                            }
                        })
                    }
                    .backgroundColor(MomentConstants.CARD_BACKGROUND_COLOR)
                    .margin({ bottom: 8 })
                }, (feedItem: FeedViewModel, index: number) => `${feedItem.feed.feedId}_${index}`)

                // åŠ è½½æ›´å¤šæŒ‡ç¤ºå™¨
                if (this.feedListState.hasMore) {
                    ListItem() {
                        this.buildLoadMoreView()
                    }
                    .onAppear(() => {
                        this.onLoadMore();
                    })
                } else if (this.feedListState.feeds.length > 0) {
                    ListItem() {
                        Text('æ²¡æœ‰æ›´å¤šäº†')
                            .fontSize(MomentConstants.FONT_SIZE_SMALL)
                            .fontColor(MomentConstants.TEXT_SECONDARY_COLOR)
                            .textAlign(TextAlign.Center)
                            .padding(16)
                    }
                }
            }
            .listDirection(Axis.Vertical)
            .scrollBar(BarState.Off)
            .edgeEffect(EdgeEffect.None)
        }
        .onRefreshing(() => {
            this.onRefresh();
        })
        .backgroundColor(MomentConstants.BACKGROUND_COLOR)
        .layoutWeight(1)
    }

    @Builder
    private buildLoadMoreView() {
        Row() {
            if (this.feedListState.isLoadingMore) {
                LoadingProgress()
                    .width(20)
                    .height(20)
                    .color(MomentConstants.PRIMARY_COLOR)
                    .margin({ right: 8 })

                Text('åŠ è½½ä¸­...')
                    .fontSize(MomentConstants.FONT_SIZE_SMALL)
                    .fontColor(MomentConstants.TEXT_SECONDARY_COLOR)
            }
        }
        .width('100%')
        .height(50)
        .justifyContent(FlexAlign.Center)
        .alignItems(VerticalAlign.Center)
    }

    @Builder
    private buildCommentInput() {
        Column() {
            // é®ç½©å±‚
            Row()
                .width('100%')
                .layoutWeight(1)
                .backgroundColor('rgba(0,0,0,0.3)')
                .onClick(() => {
                    this.commentInputState.isVisible = false;
                    this.commentText = '';
                })

            // è¾“å…¥æ¡†åŒºåŸŸ
            Row() {
                TextInput({ placeholder: this.commentInputState.placeholder, text: this.commentText })
                    .layoutWeight(1)
                    .height(40)
                    .backgroundColor('#FFFFFF')
                    .borderRadius(20)
                    .padding({ left: 16, right: 16 })
                    .onChange((value: string) => {
                        this.commentText = value;
                    })

                Button('å‘é€')
                    .height(40)
                    .backgroundColor(this.commentText.trim() ? MomentConstants.PRIMARY_COLOR : '#CCCCCC')
                    .borderRadius(20)
                    .margin({ left: 8 })
                    .enabled(!!this.commentText.trim())
                    .onClick(() => {
                        const targetFeed = this.feedListState.feeds.find(f => f.feed.feedId === this.commentInputState.feedId);
                        if (targetFeed) {
                            this.interactionEvents.onComment(targetFeed, this.commentText, this.commentInputState.replyTo);
                        }
                    })
            }
            .width('100%')
            .padding(16)
            .backgroundColor('#FFFFFF')
        }
        .width('100%')
        .height('100%')
        .position({ x: 0, y: 0 })
        .zIndex(999)
    }

    @Builder
    private buildFloatingActionButton() {
        Button() {
            Image($r('app.media.icon')) // TODO: ä½¿ç”¨ç¼–è¾‘å›¾æ ‡
                .width(24)
                .height(24)
                .fillColor('#FFFFFF')
        }
        .width(56)
        .height(56)
        .borderRadius(28)
        .backgroundColor(MomentConstants.PRIMARY_COLOR)
        .shadow({
            radius: 8,
            color: 'rgba(0,0,0,0.2)',
            offsetX: 0,
            offsetY: 2
        })
        .position({
            x: '100%',
            y: '100%'
        })
        .translate({
            x: -72, // 56 + 16 margin
            y: -72
        })
        .zIndex(100)
        .onClick(() => {
            this.mainNavPathStack.pushPathByName(momentNavigationDestinations.PostFeedPage, {} as Record<string, Object>)
        })
    }
}